<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StonkWorks</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="manifest" href="site.webmanifest">
    <style>
        :root {
            color-scheme: light dark;
            --bg: #f9f9fb;
            --panel: #ffffff;
            --panel-border: #e2e3e9;
            --text: #1f2430;
            --muted: #545b6b;
            --accent: #3c82f6;
            --accent-bg: rgba(60, 130, 246, 0.15);
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #1a1d28;
                --panel: #23273a;
                --panel-border: #33384d;
                --text: #e4e6eb;
                --muted: #9ca3af;
            }
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
            padding: 1.25rem;
        }

        h1 {
            margin: 0;
            font-size: 1.75rem;
            font-weight: 700;
            letter-spacing: -0.01em;
        }

        h2 {
            margin: 0;
        }

        p {
            margin: 0.5rem 0;
            color: var(--muted);
        }

        .layout {
            display: grid;
            gap: 1.25rem;
            grid-template-columns: minmax(280px, 340px) 1fr;
            align-items: flex-start;
        }

        .panel {
            background: var(--panel);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 1.4rem;
            box-shadow: 0 12px 38px -22px rgba(31, 36, 48, 0.4);
        }

        .section-heading {
            margin: 0 0 0.65rem 0;
            font-size: 1.05rem;
            font-weight: 600;
            letter-spacing: -0.005em;
        }

        label {
            font-weight: 600;
            display: block;
            margin-bottom: 0.35rem;
            font-size: 0.88rem;
        }

        input[type="number"],
        input[type="text"],
        input[type="file"] {
            width: 100%;
            font: inherit;
            padding: 0.6rem 0.75rem;
            border-radius: 8px;
            border: 1px solid var(--panel-border);
            background: var(--bg);
            color: var(--text);
            box-sizing: border-box;
        }

        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-bg);
        }

        input[type="number"] {
            appearance: textfield;
            -moz-appearance: textfield;
        }

        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .file-drop {
            border: 2px dashed var(--panel-border);
            border-radius: 12px;
            padding: 1.5rem;
            text-align: center;
            transition: border-color 0.2s ease, background 0.2s ease;
            cursor: pointer;
            color: var(--muted);
        }

        .file-drop:hover {
            border-color: var(--accent);
        }

        .file-drop.dragover {
            border-color: var(--accent);
            background: var(--accent-bg);
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.35rem 0.7rem;
            border-radius: 999px;
            background: var(--accent-bg);
            color: var(--accent);
            font-size: 0.8rem;
            font-weight: 600;
            margin-top: 0.75rem;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 0.85rem;
            margin-bottom: 1.35rem;
        }

        .metrics .metric {
            background: linear-gradient(135deg, rgba(60, 130, 246, 0.08), rgba(60, 130, 246, 0.04));
            border: 1px solid rgba(60, 130, 246, 0.18);
            border-radius: 10px;
            padding: 0.9rem 1rem;
        }

        .metric-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.4rem;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0;
        }

        .metric-subtext {
            margin-top: 0.35rem;
            font-size: 0.75rem;
            color: var(--muted);
            letter-spacing: 0.02em;
        }

        .metric-delta {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            margin-top: 0.45rem;
            font-size: 0.78rem;
            font-weight: 600;
        }

        .delta-positive {
            color: #059669;
        }

        .delta-zero {
            color: var(--muted);
        }

        .delta-negative {
            color: #dc2626;
        }

        .chart-panel {
            min-height: 600px;
            position: relative;
        }

        .upcoming-section {
            margin-top: 2rem;
            display: grid;
            gap: 1rem;
        }

        .upcoming-empty {
            border: 1px dashed var(--panel-border);
            border-radius: 10px;
            padding: 1rem 1.25rem;
            text-align: center;
            color: var(--muted);
            font-size: 0.9rem;
        }

        .upcoming-table-wrapper {
            overflow-x: auto;
        }

        .upcoming-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 600px;
            background: var(--panel);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            overflow: hidden;
        }

        .upcoming-table th,
        .upcoming-table td {
            padding: 0.85rem 1rem;
            border-bottom: 1px solid var(--panel-border);
            text-align: left;
            font-size: 0.85rem;
            vertical-align: top;
        }

        .upcoming-table th {
            background: linear-gradient(135deg, rgba(60, 130, 246, 0.12), rgba(60, 130, 246, 0.05));
            font-weight: 600;
            color: var(--text);
        }

        .upcoming-table tbody tr:last-child td {
            border-bottom: none;
        }

        .upcoming-details-cell {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .upcoming-grant-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.35rem 0.75rem;
            border-radius: 6px;
            border: 1px solid var(--panel-border);
            background: var(--bg);
            font-size: 0.8rem;
            color: var(--muted);
            max-width: 100%;
        }

        .upcoming-grant-chip span:first-child {
            color: var(--text);
            font-weight: 600;
            min-width: 24px;
            text-align: right;
        }

        .upcoming-grant-chip span:last-child {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 300px;
        }

        #chartContainer {
            position: relative;
            min-height: 400px;
        }

        #chartContainer canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .empty-state {
            text-align: center;
            color: var(--muted);
            border: 1px dashed var(--panel-border);
            border-radius: 12px;
            padding: 3rem 2rem;
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chip-list {
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
            margin-top: 1rem;
        }

        .chip {
            border-radius: 8px;
            padding: 0.6rem 0.8rem;
            border: 1px solid var(--panel-border);
            background: var(--bg);
            font-size: 0.8rem;
            line-height: 1.4;
        }

        .chip strong {
            display: block;
            margin-bottom: 0.2rem;
            color: var(--text);
        }

        .chip small {
            color: var(--muted);
        }

        .exchange-note {
            font-size: 0.8rem;
            color: var(--muted);
            margin-top: 0.6rem;
            padding: 0.55rem 0.65rem;
            border-radius: 8px;
            border: 1px dashed var(--panel-border);
            background: rgba(60, 130, 246, 0.06);
        }

        .hidden {
            display: none !important;
        }

        .divider {
            height: 1px;
            background: var(--panel-border);
            margin: 1.25rem 0;
        }

        .result-box {
            background: var(--bg);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 0.75rem 0.85rem;
            margin-top: 0.75rem;
            font-size: 0.85rem;
            line-height: 1.5;
        }

        .result-box strong {
            display: block;
            margin-bottom: 0.25rem;
            color: var(--text);
        }

        #chart-tooltip {
            position: absolute;
            background: rgba(31, 36, 48, 0.9);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 0.6rem 0.8rem;
            border-radius: 8px;
            pointer-events: none;
            transition: opacity 0.15s ease, left 0.1s ease, top 0.1s ease;
            font-size: 0.75rem;
            line-height: 1.3;
            opacity: 0;
            z-index: 1000;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            min-width: 240px;
        }

        #chart-tooltip .tooltip-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.15);
        }

        #chart-tooltip table {
            border-collapse: collapse;
            min-width: 280px;
        }

        #chart-tooltip th,
        #chart-tooltip td {
            padding: 0.3rem 0.5rem;
            text-align: right;
            white-space: nowrap;
        }

        #chart-tooltip th:first-child,
        #chart-tooltip td:first-child {
            text-align: left;
            padding-left: 0;
        }

        #chart-tooltip td:nth-child(2) {
            text-align: left;
        }

        #chart-tooltip tfoot {
            border-top: 1px solid rgba(255, 255, 255, 0.15);
        }

        #chart-tooltip tfoot td {
            padding-top: 0.5rem;
            font-weight: 600;
        }

        @media (max-width: 1024px) {
            body {
                padding: 1rem;
            }

            .layout {
                grid-template-columns: 1fr;
            }

            .metrics {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            }

            .upcoming-table {
                min-width: 100%;
            }
        }

        .btn-secondary {
            background: var(--bg);
            border: 1px solid var(--panel-border);
            color: var(--muted);
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        .btn-secondary:hover {
            border-color: var(--muted);
            color: var(--text);
        }

        /* Toggle Switch */
        .toggle-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text);
            cursor: pointer;
        }

        .toggle-switch {
            position: relative;
            width: 36px;
            height: 20px;
            background: var(--panel-border);
            border-radius: 20px;
            transition: background 0.2s;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: transform 0.2s;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        input:checked+.toggle-switch {
            background: var(--accent);
        }

        input:checked+.toggle-switch::after {
            transform: translateX(16px);
        }

        /* Range Overlay */
        #rangeOverlay {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 50;
            display: flex;
            gap: 1.5rem;
            align-items: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        #rangeOverlay.visible {
            opacity: 1;
        }

        .range-metric {
            text-align: center;
        }

        .range-metric-label {
            font-size: 0.7rem;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.2rem;
        }

        .range-metric-value {
            font-weight: 700;
            font-size: 1.1rem;
            color: var(--accent);
        }

        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .modal-backdrop.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background: var(--panel);
            border: 1px solid var(--panel-border);
            border-radius: 16px;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 50px -12px rgba(0, 0, 0, 0.25);
            transform: scale(0.95);
            transition: transform 0.2s ease;
            position: relative;
        }

        .modal-backdrop.visible .modal-content {
            transform: scale(1);
        }

        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--muted);
            padding: 0.5rem;
            line-height: 1;
            border-radius: 8px;
            transition: background 0.2s;
        }

        .modal-close:hover {
            background: var(--bg);
            color: var(--text);
        }

        .help-step {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            align-items: flex-start;
        }

        .help-step-number {
            background: var(--accent-bg);
            color: var(--accent);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            flex-shrink: 0;
            margin-top: 0.1rem;
        }

        .help-step-content h3 {
            margin: 0 0 0.25rem 0;
            font-size: 1rem;
        }

        .help-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1rem;
            margin-left: 1rem;
            flex-shrink: 0;
        }

        #dragOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(60, 130, 246, 0.9);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            backdrop-filter: blur(4px);
        }

        #dragOverlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #dragOverlay .icon {
            font-size: 4rem;
            margin-bottom: 1rem;
        }

        #dragOverlay h2 {
            font-size: 2rem;
            margin: 0;
        }

        #dragOverlay * {
            pointer-events: none;
        }
    </style>
</head>

<body>
    <header style="display: flex; justify-content: space-between; align-items: center;">
        <h1 style="margin: 0;">StonkWorks</h1>
        <button id="helpBtn" class="btn-secondary help-btn" aria-label="Help">?</button>
    </header>

    <div class="layout">
        <aside class="panel" aria-label="controls">
            <h2 class="section-heading">üìÅ Grant Files</h2>
            <p class="text-sm text-muted" style="margin-bottom: 1rem;">Upload ShareWorks HTML exports</p>

            <div id="uploadSection" class="file-drop">
                <div class="upload-icon">üìÇ</div>
                <p>Click here to select files</p>
                <p class="text-sm text-muted">Supports multiple files</p>
                <input type="file" id="fileInput" multiple accept=".html,text/html" class="hidden">
            </div>

            <div class="file-controls">
                <span id="fileCount" class="file-badge hidden">0 grants loaded</span>
                <button id="clearCacheBtn" class="btn-secondary hidden">Clear Data</button>
            </div>

            <div class="divider"></div>

            <h2 class="section-heading">üí∞ Share Price</h2>
            <label class="input-label" for="sharePrice">Current share price (USD)</label>
            <input type="number" id="sharePrice" class="input-field" placeholder="0.00" step="0.01">
            <div id="exchangeRateNotice" class="exchange-note hidden" aria-live="polite"></div>

            <div class="divider"></div>

            <h2 class="section-heading">üîÆ What If Calculator</h2>
            <label for="priceChange">Future price change (%)</label>
            <input id="priceChange" type="number" step="0.1" value="0" placeholder="e.g., 50 for +50%">
            <div class="result-box" id="priceChangeResult">
                Enter a share price and % change to calculate projected value.
            </div>

            <section id="grantSummary" class="chip-list hidden" aria-live="polite"></section>
        </aside>

        <main class="panel chart-panel" aria-live="polite">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.65rem;">
                <h2 class="section-heading" style="margin: 0;">üìà Vesting Timeline</h2>
                <label class="toggle-wrapper">
                    <input type="checkbox" id="futureToggle" class="hidden">
                    <div class="toggle-switch"></div>
                    <span>Future only</span>
                </label>
            </div>
            <div class="metrics" id="metrics">
                <div class="metric">
                    <div class="metric-label">Total Vested</div>
                    <div class="metric-value" id="totalShares">0</div>
                    <div class="metric-subtext">As of today</div>
                    <div class="metric-delta delta-zero" id="shareDeltaDisplay">Awaiting future vest</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Current Value</div>
                    <div class="metric-value" id="totalValue">$0.00</div>
                    <div class="metric-delta delta-zero" id="valueDeltaDisplay">Enter share price to see change</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Projected Value</div>
                    <div class="metric-value" id="projectedValue">$0.00</div>
                    <div class="metric-subtext">Based on % change</div>
                </div>
            </div>

            <div id="chartContainer" class="empty-state" role="status">
                <div id="rangeOverlay">
                    <div class="range-metric">
                        <div class="range-metric-label">Shares Vested</div>
                        <div class="range-metric-value" id="rangeShares">0</div>
                    </div>
                    <div class="range-metric">
                        <div class="range-metric-label">Value Gain</div>
                        <div class="range-metric-value" id="rangeValue">$0.00</div>
                    </div>
                    <div class="range-metric">
                        <div class="range-metric-label">Period</div>
                        <div class="range-metric-value" id="rangePeriod" style="font-size: 0.8rem; font-weight: 600;">0
                            days</div>
                    </div>
                </div>
                <p>üì§ Load one or more grant files to see your vesting progress chart</p>
            </div>

            <section id="upcomingSection" class="upcoming-section" aria-live="polite">
                <h3 class="section-heading">üóì Upcoming Vests</h3>
                <div id="upcomingEmpty" class="upcoming-empty">Load grant files to see upcoming vesting events.</div>
                <div class="upcoming-table-wrapper">
                    <table id="upcomingTable" class="upcoming-table hidden">
                        <thead>
                            <tr>
                                <th scope="col">Vest Date</th>
                                <th scope="col">Time Until</th>
                                <th scope="col">Shares</th>
                                <th scope="col">Value</th>
                                <th scope="col">Details</th>
                            </tr>
                        </thead>
                        <tbody id="upcomingTableBody"></tbody>
                    </table>
                </div>
            </section>
        </main>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.js"></script>
    <script>
        // DOM Elements
        const fileInput = document.getElementById('fileInput');
        const uploadSection = document.getElementById('uploadSection');
        const fileCountBadge = document.getElementById('fileCount');
        const sharePriceInput = document.getElementById('sharePrice');
        const priceChangeInput = document.getElementById('priceChange');
        const priceChangeResult = document.getElementById('priceChangeResult');
        const totalSharesEl = document.getElementById('totalShares');
        const totalValueEl = document.getElementById('totalValue');
        const projectedValueEl = document.getElementById('projectedValue');
        const chartContainer = document.getElementById('chartContainer');
        const grantSummary = document.getElementById('grantSummary');
        const upcomingTable = document.getElementById('upcomingTable');
        const upcomingTableBody = document.getElementById('upcomingTableBody');
        const upcomingEmptyState = document.getElementById('upcomingEmpty');
        const exchangeRateNotice = document.getElementById('exchangeRateNotice');
        const shareDeltaDisplay = document.getElementById('shareDeltaDisplay');
        const valueDeltaDisplay = document.getElementById('valueDeltaDisplay');
        const clearCacheBtn = document.getElementById('clearCacheBtn');
        const futureToggle = document.getElementById('futureToggle');
        const rangeOverlay = document.getElementById('rangeOverlay');
        const rangeSharesEl = document.getElementById('rangeShares');
        const rangeValueEl = document.getElementById('rangeValue');
        const rangePeriodEl = document.getElementById('rangePeriod');

        // State
        const CACHE_KEY = 'shareworks_visualizer_data';
        let grantData = [];
        let timeline = [];
        let chartInstance = null;
        let currencyCode = 'USD';
        let baselineBreakdown = {};
        let baselineTotalShares = 0;
        let audUsdRate = null;
        let exchangeRateTimestamp = null;
        let showFutureOnly = false;
        let selectionStart = null;
        let selectionEnd = null;
        let isDragging = false;
        const MS_IN_DAY = 24 * 60 * 60 * 1000;
        const usdFormatter = new Intl.NumberFormat(undefined, {
            style: 'currency',
            currency: 'USD',
            maximumFractionDigits: 2
        });

        /**
         * Load and parse HTML grant files
         */

        const processParsedGrants = (extracted) => {
            if (!extracted.length) {
                alert('‚ö†Ô∏è Could not parse grant data. Ensure files are "Employee Grant Details" exports from ShareWorks.');
                return;
            }

            // Sort grants by date ascending
            grantData = extracted.sort((a, b) => {
                const dateA = parseDate(a.grantDate) || new Date(0);
                const dateB = parseDate(b.grantDate) || new Date(0);
                return dateA - dateB;
            });

            updateUIWithData();
            saveToCache();
        };

        const updateUIWithData = () => {
            fileCountBadge.textContent = `${grantData.length} grant${grantData.length === 1 ? '' : 's'} loaded`;
            fileCountBadge.classList.remove('hidden');
            clearCacheBtn.classList.remove('hidden');
            uploadSection.classList.add('hidden');

            currencyCode = detectCurrency(grantData);
            renderGrantSummary(grantData);
            buildTimeline();
            updateMetrics();
        };

        /**
         * Load and parse HTML grant files
         */
        const loadFiles = files => {
            const relevantFiles = Array.from(files).filter(file =>
                file.name.toLowerCase().endsWith('.html') || file.type === 'text/html'
            );

            if (!relevantFiles.length) {
                alert('‚ö†Ô∏è Please select ShareWorks HTML files.');
                return;
            }

            Promise.all(relevantFiles.map(file =>
                file.text().then(raw => ({ raw, name: file.name }))
            ))
                .then(parsed => {
                    const extracted = parsed.map(parseGrantHtml).filter(Boolean);
                    processParsedGrants(extracted);
                })
                .catch(err => {
                    console.error('Error parsing files:', err);
                    alert('‚ùå Error parsing files. Check the console for details.');
                });
        };

        /**
         * Parse a single ShareWorks HTML grant file
         */
        const parseGrantHtml = ({ raw, name }) => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(raw, 'text/html');

            const grantInfo = gatherGrantMeta(doc);
            if (!grantInfo.name) {
                console.warn('Skipping file without grant name:', name);
                return null;
            }

            const { entries, total } = extractVestingSchedule(doc);
            if (!entries.length) {
                console.warn('Skipping grant with no vesting rows:', name);
                return null;
            }

            return {
                id: crypto.randomUUID(),
                fileName: name,
                ...grantInfo,
                entries,
                grantTotal: total
            };
        };

        /**
         * Extract grant metadata from HTML
         */
        const extractFieldValue = strongEl => {
            const parts = [];
            let node = strongEl.nextSibling;
            while (node) {
                if (node.nodeType === Node.ELEMENT_NODE && node.tagName && node.tagName.toLowerCase() === 'br') {
                    break;
                }

                const textContent = node.textContent?.trim?.() || '';
                if (textContent) {
                    parts.push(textContent);
                }

                node = node.nextSibling;
            }

            return parts.join(' ').replace(/\s+/g, ' ').trim();
        };

        const extractNumericValue = text => {
            if (!text) return null;
            const match = text.replace(/\u00a0/g, ' ').match(/[-+]?\d[\d,]*(?:\.\d+)?(?:[eE][-+]?\d+)?/);
            if (!match) return null;
            return Number.parseFloat(match[0].replace(/,/g, ''));
        };

        const gatherGrantMeta = doc => {
            const meta = {
                name: '',
                grantDate: '',
                grantPrice: 0,
                type: 'Unknown',
                currency: 'USD'
            };

            const strongTags = Array.from(doc.querySelectorAll('p strong'));
            strongTags.forEach(tag => {
                const label = tag.textContent.trim();
                const valueText = extractFieldValue(tag);
                if (!valueText) return;

                if (label.startsWith('Grant Name')) {
                    meta.name = valueText;
                    const lowerName = valueText.toLowerCase();
                    if (lowerName.includes('rsu')) meta.type = 'RSU';
                    if (lowerName.includes('option') || lowerName.includes('nqso') || lowerName.includes('qso')) meta.type = 'Option';
                }
                if (label.startsWith('Grant Date')) {
                    meta.grantDate = valueText;
                }
                if (label.startsWith('Grant Price')) {
                    const numeric = extractNumericValue(valueText);
                    meta.grantPrice = Number.isFinite(numeric) ? numeric : 0;
                    const currencyMatch = valueText.match(/\$\s*[\d.,]+\s+([A-Z]{3})\b/);
                    if (currencyMatch) {
                        const code = currencyMatch[1];
                        const validCurrencies = ['USD', 'EUR', 'GBP', 'AUD', 'CAD', 'JPY', 'CNY', 'INR', 'NZD', 'CHF', 'SGD', 'HKD'];
                        if (validCurrencies.includes(code)) {
                            meta.currency = code;
                        }
                    }
                }
            });

            return meta;
        };

        /**
         * Extract vesting schedule table from HTML
         */
        const extractVestingSchedule = doc => {
            const table = doc.querySelector("table[id^='Vest Schedule']");
            if (!table) return { entries: [], total: 0 };

            const rows = Array.from(table.querySelectorAll('tr'));
            const bodyRows = rows.filter(row => row.querySelector('td'));
            const entries = [];
            let cumulative = 0;

            bodyRows.forEach(row => {
                const cells = Array.from(row.querySelectorAll('td'));
                if (cells.length < 6) return;

                const vestDateText = cells[0].textContent.trim();
                const grantCell = cells[2]; // Granted column
                const outstandingCell = cells[5]; // Outstanding column

                const date = parseDate(vestDateText);
                if (!date) return;

                const granted = Number.parseFloat(grantCell.textContent.replace(/[^0-9.\-]/g, '')) || 0;
                cumulative += granted;

                const outstanding = Number.parseFloat(outstandingCell.textContent.replace(/[^0-9.\-]/g, '')) || cumulative;

                entries.push({ date, granted, cumulative, outstanding });
            });

            return { entries, total: cumulative };
        };

        /**
         * Parse date from ShareWorks format (e.g., "15-Feb-2023")
         */
        const parseDate = value => {
            const clean = (value || '').trim();
            const ordinalStripped = clean.replace(/(st|nd|rd|th)/gi, '');
            const parts = ordinalStripped.split('-');
            if (parts.length !== 3) return null;

            const [dayPart, monthPart, yearPart] = parts;
            const monthNames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
            const monthIndex = monthNames.indexOf(monthPart.slice(0, 3).toLowerCase());
            const day = Number.parseInt(dayPart, 10);
            const year = Number.parseInt(yearPart, 10);

            if (monthIndex < 0 || Number.isNaN(day) || Number.isNaN(year)) return null;
            return new Date(Date.UTC(year, monthIndex, day));
        };

        /**
         * Detect primary currency from all grants
         */
        const detectCurrency = grants => {
            const codes = Array.from(new Set(grants.map(grant => grant.currency).filter(Boolean)));
            if (codes.length > 1) {
                console.warn('Multiple currencies detected. Using first:', codes);
            }
            return codes[0] || 'USD';
        };

        /**
         * Build unified timeline across all grants
         */
        const buildTimeline = () => {
            const points = new Map();

            grantData.forEach(grant => {
                grant.entries.forEach(entry => {
                    if (!entry.date) return;
                    const key = entry.date.toISOString().slice(0, 10);
                    if (!points.has(key)) {
                        points.set(key, { date: entry.date, totals: new Map() });
                    }
                    const item = points.get(key);
                    item.totals.set(grant.id, entry.cumulative);
                });
            });

            const sorted = Array.from(points.values()).sort((a, b) => a.date - b.date);

            // Fill in missing data points with last known value
            timeline = sorted.map(point => {
                const breakdown = {};
                grantData.forEach(grant => {
                    if (point.totals.has(grant.id)) {
                        breakdown[grant.id] = point.totals.get(grant.id);
                    } else {
                        const lastValue = findLastVestedValue(grant, point.date);
                        breakdown[grant.id] = lastValue;
                    }
                });
                return { date: point.date, breakdown };
            });

            renderChart();
        };

        /**
         * Find the last vested value for a grant before a reference date
         */
        const findLastVestedValue = (grant, referenceDate) => {
            const relevant = grant.entries.filter(entry => entry.date && entry.date <= referenceDate);
            if (!relevant.length) return 0;
            return relevant[relevant.length - 1].cumulative;
        };

        /**
         * Sum all grant values at a specific date
         */
        const sumAtDate = dateBreakdown => {
            return Object.values(dateBreakdown).reduce((acc, val) => acc + (val || 0), 0);
        };

        /**
         * Calculate intrinsic value for a breakdown at a given price
         */
        const calculateValueFromBreakdown = (breakdown, price) => {
            if (!breakdown || !Number.isFinite(price)) return 0;
            return grantData.reduce((acc, grant) => {
                const amount = breakdown[grant.id] || 0;
                if (!amount) return acc;
                const strike = grant.type === 'Option' ? grant.grantPrice : 0;
                const perShare = grant.type === 'Option' ? Math.max(price - strike, 0) : price;
                return acc + amount * perShare;
            }, 0);
        };

        /**
         * Get the next future timeline point after reference date
         */
        const getNextFuturePoint = referenceDate => {
            if (!timeline.length) return null;
            return timeline.find(point => point.date > referenceDate) || null;
        };

        /**
         * Create a short, readable name for a grant
         */
        const createGrantLabel = grant => {
            const date = grant.grantDate || 'Unknown';
            const type = grant.type || 'Grant';
            const units = grant.grantTotal ? formatNumber(grant.grantTotal) : '0';
            return `${date}, ${type}, ${units}`;
        };

        /**
         * Render the Chart.js chart
         */
        const renderChart = () => {
            if (!timeline.length) {
                if (chartInstance) {
                    chartInstance.destroy();
                    chartInstance = null;
                }
                chartContainer.innerHTML = '<p>üì§ Load one or more grant files to see your vesting progress chart</p>';
                chartContainer.className = 'empty-state';
                return;
            }

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            let displayTimeline = timeline;
            if (showFutureOnly) {
                displayTimeline = timeline.filter(point => point.date >= today);
                // Ensure we have a starting point if possible
                if (displayTimeline.length === 0 && timeline.length > 0) {
                    // If all vests are in the past, show at least the last one
                    displayTimeline = [timeline[timeline.length - 1]];
                } else if (displayTimeline.length > 0 && displayTimeline[0].date > today) {
                    // Add a "today" point if the first future vest is later
                    const lastPast = timeline.filter(p => p.date < today).pop();
                    if (lastPast) {
                        displayTimeline.unshift({ ...lastPast, date: today });
                    }
                }
            }

            const labels = displayTimeline.map(point => point.date.toISOString().slice(0, 10));
            const datasets = grantData.map((grant, index) => {
                const color = generateColor(index);
                const data = displayTimeline.map(point => point.breakdown[grant.id] || 0);
                return {
                    label: createGrantLabel(grant),
                    data,
                    fill: true,
                    backgroundColor: color.alpha,
                    borderColor: color.base,
                    borderWidth: 2,
                    tension: 0.3,
                    pointRadius: 2,
                    pointHoverRadius: 5
                };
            });

            const price = Number.parseFloat(sharePriceInput.value) || 0;
            const intrinsicTotals = grantData.map(grant => {
                const strike = grant.type === 'Option' ? grant.grantPrice : 0;
                return displayTimeline.map(point => {
                    const amount = point.breakdown[grant.id] || 0;
                    const perShare = grant.type === 'Option' ? Math.max(price - strike, 0) : price;
                    return amount * perShare;
                });
            });
            const valueTotals = displayTimeline.map((_, idx) =>
                intrinsicTotals.reduce((acc, grantSeries) => acc + (grantSeries[idx] || 0), 0)
            );

            const tooltipHandler = createTooltipHandler(valueTotals, displayTimeline);

            // Custom plugin to draw vertical "today" line
            const todayLinePlugin = {
                id: 'todayLine',
                afterDraw: (chart) => {
                    if (showFutureOnly) return; // Don't draw today line if we are only showing future (it's the start)

                    const ctx = chart.ctx;
                    const xAxis = chart.scales.x;
                    const yAxis = chart.scales.y;

                    const todayIso = new Date().toISOString().slice(0, 10);
                    const todayIndex = labels.indexOf(todayIso);

                    // If today isn't an exact vest date, find where it falls
                    let xPosition;
                    if (todayIndex >= 0) {
                        xPosition = xAxis.getPixelForValue(todayIndex);
                    } else {
                        // Find position between two dates
                        const todayDate = new Date();
                        const datesBeforeToday = displayTimeline.filter(p => p.date <= todayDate);
                        if (datesBeforeToday.length === 0) return;
                        if (datesBeforeToday.length === displayTimeline.length) return;

                        const lastBeforeIdx = datesBeforeToday.length - 1;
                        xPosition = xAxis.getPixelForValue(lastBeforeIdx) +
                            ((xAxis.getPixelForValue(lastBeforeIdx + 1) - xAxis.getPixelForValue(lastBeforeIdx)) * 0.5);
                    }

                    // Draw the line
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(xPosition, yAxis.top);
                    ctx.lineTo(xPosition, yAxis.bottom);
                    ctx.strokeStyle = 'rgba(239, 68, 68, 0.8)'; // Red
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();

                    // Draw label
                    ctx.font = 'bold 11px Inter, sans-serif';
                    ctx.fillStyle = 'rgba(239, 68, 68, 0.9)';
                    ctx.textAlign = 'center';
                    ctx.fillText('TODAY', xPosition, yAxis.top - 5);
                    ctx.restore();
                }
            };

            const crosshairPlugin = {
                id: 'crosshair',
                afterDraw: (chart) => {
                    if (chart.tooltip?._active?.length && !isDragging) {
                        const ctx = chart.ctx;
                        const x = chart.tooltip._active[0].element.x;
                        const topY = chart.scales.y.top;
                        const bottomY = chart.scales.y.bottom;

                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(x, topY);
                        ctx.lineTo(x, bottomY);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = 'rgba(60, 130, 246, 0.5)';
                        ctx.setLineDash([4, 4]);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            };

            const selectionPlugin = {
                id: 'selection',
                afterDraw: (chart) => {
                    if (selectionStart !== null && selectionEnd !== null) {
                        const ctx = chart.ctx;
                        const xAxis = chart.scales.x;
                        const yAxis = chart.scales.y;

                        const startX = xAxis.getPixelForValue(selectionStart);
                        const endX = xAxis.getPixelForValue(selectionEnd);

                        ctx.save();
                        ctx.fillStyle = 'rgba(60, 130, 246, 0.1)';
                        ctx.fillRect(Math.min(startX, endX), yAxis.top, Math.abs(endX - startX), yAxis.bottom - yAxis.top);
                        ctx.restore();
                    }
                }
            };

            const config = {
                type: 'line',
                data: {
                    labels,
                    datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false, // Disable animation for smoother dragging
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                boxWidth: 8,
                                padding: 15,
                                font: {
                                    size: 11,
                                    weight: '600'
                                }
                            }
                        },
                        tooltip: {
                            enabled: false,
                            external: tooltipHandler
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    onHover: (event, elements) => {
                        // Handle drag selection
                        if (isDragging && chartInstance) {
                            const points = chartInstance.getElementsAtEventForMode(event, 'index', { intersect: false }, true);
                            if (points.length) {
                                selectionEnd = points[0].index;
                                chartInstance.update('none'); // Update without animation
                                updateRangeOverlay(displayTimeline);
                            }
                        }
                    },
                    scales: {
                        y: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Vested Shares',
                                font: {
                                    weight: '600'
                                }
                            },
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        x: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Vest Date',
                                font: {
                                    weight: '600'
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            },
                            ticks: {
                                callback: value => formatChartLabel(labels[value]),
                                maxRotation: 0,
                                autoSkipPadding: 12
                            }
                        }
                    }
                },
                plugins: [todayLinePlugin, crosshairPlugin, selectionPlugin]
            };

            if (!chartInstance) {
                const canvas = document.createElement('canvas');
                chartContainer.className = '';
                // Keep the overlay div
                const overlay = chartContainer.querySelector('#rangeOverlay');
                chartContainer.innerHTML = '';
                if (overlay) chartContainer.appendChild(overlay);

                chartContainer.appendChild(canvas);
                chartInstance = new Chart(canvas.getContext('2d'), config);

                // Add event listeners to canvas
                canvas.addEventListener('mousedown', (evt) => {
                    const points = chartInstance.getElementsAtEventForMode(evt, 'index', { intersect: false }, true);
                    if (points.length) {
                        isDragging = true;
                        selectionStart = points[0].index;
                        selectionEnd = points[0].index;
                        chartInstance.update('none');
                        updateRangeOverlay(displayTimeline);
                    }
                });

                window.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                    }
                });

                // Clear selection on click outside (simple heuristic)
                document.addEventListener('click', (evt) => {
                    if (!chartContainer.contains(evt.target)) {
                        selectionStart = null;
                        selectionEnd = null;
                        if (chartInstance) chartInstance.update('none');
                        rangeOverlay.classList.remove('visible');
                    }
                });

            } else {
                chartInstance.config.data = config.data;
                chartInstance.options = config.options;
                chartInstance.options.plugins.tooltip.external = tooltipHandler;
                chartInstance.update();
            }
        };

        /**
         * Create custom tooltip handler for hover information
         */
        const createTooltipHandler = (valueSeries, currentTimeline) => {
            const tooltipEl = document.getElementById('chart-tooltip') || createTooltipElement();

            return context => {
                const { chart, tooltip } = context;
                if (!tooltip || tooltip.opacity === 0 || isDragging) { // Hide tooltip while dragging
                    tooltipEl.style.opacity = 0;
                    return;
                }

                const index = tooltip.dataPoints?.[0]?.dataIndex ?? 0;
                const point = currentTimeline[index];
                if (!point) return;

                const sharePrice = Number.parseFloat(sharePriceInput.value) || 0;
                const rows = grantData.map((grant, datasetIdx) => {
                    const value = point.breakdown[grant.id] || 0;
                    const strike = grant.type === 'Option' ? grant.grantPrice : 0;
                    const perShare = grant.type === 'Option' ? Math.max(sharePrice - strike, 0) : sharePrice;
                    const worth = sharePrice > 0 ? value * perShare : null;
                    const color = chart.config.data.datasets[datasetIdx]?.borderColor || '#999';
                    const valueDisplay = worth === null ? '‚Äî' : formatCurrency(worth);

                    const percentVested = grant.grantTotal > 0 ? (value / grant.grantTotal) * 100 : 0;
                    const percentDisplay = percentVested.toFixed(0) + '%';

                    return `<tr>
                        <td><span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${color};margin-right:6px;"></span></td>
                        <td style="max-width: 140px; overflow: hidden; text-overflow: ellipsis; font-size: 0.75rem;">
                            ${createGrantLabel(grant)}
                        </td>
                        <td style="font-size: 0.7rem; opacity: 0.8;">${percentDisplay}</td>
                        <td>${formatNumber(value)}</td>
                        <td>${valueDisplay}</td>
                    </tr>`;
                }).join('');

                const totalShares = sumAtDate(point.breakdown);
                const totalValue = valueSeries[index] || 0;
                const totalSharesDisplay = formatNumber(totalShares);
                const totalValueDisplay = sharePrice > 0 ? formatCurrency(totalValue) : '‚Äî';

                const html = `
                    <div class="tooltip-title" style="padding-bottom: 0.3rem; margin-bottom: 0.3rem;">üìÖ ${formatDateDisplay(point.date)}</div>
                    <div class="tooltip-body">
                        <table style="width: 100%;">
                            <thead>
                                <tr style="font-size: 0.7rem; color: rgba(255,255,255,0.6);">
                                    <th></th>
                                    <th>Grant</th>
                                    <th>%</th>
                                    <th>Shares</th>
                                    <th>Value</th>
                                </tr>
                            </thead>
                            <tbody>${rows}</tbody>
                            <tfoot>
                                <tr style="border-top: 1px solid rgba(255,255,255,0.15);">
                                    <td></td>
                                    <td><strong>Total</strong></td>
                                    <td></td>
                                    <td><strong>${totalSharesDisplay}</strong></td>
                                    <td><strong>${totalValueDisplay}</strong></td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>`;

                tooltipEl.innerHTML = html;

                const { offsetLeft: positionX, offsetTop: positionY } = chart.canvas;
                const tooltipWidth = tooltipEl.offsetWidth;
                const tooltipHeight = tooltipEl.offsetHeight;
                const chartWidth = chart.width;

                // Default position: to the right of the cursor
                let left = positionX + tooltip.caretX + 20;
                let top = positionY + tooltip.caretY;

                // If tooltip goes off the right edge, flip to the left
                if (left + tooltipWidth > positionX + chartWidth) {
                    left = positionX + tooltip.caretX - tooltipWidth - 20;
                }

                // Ensure tooltip doesn't go off the top or bottom
                if (top + tooltipHeight > positionY + chart.height) {
                    top = positionY + chart.height - tooltipHeight;
                }
                if (top < positionY) {
                    top = positionY;
                }

                tooltipEl.style.opacity = 1;
                tooltipEl.style.left = left + 'px';
                tooltipEl.style.top = top + 'px';
            };
        };

        const updateRangeOverlay = (currentTimeline) => {
            if (selectionStart === null || selectionEnd === null) return;

            const startIdx = Math.min(selectionStart, selectionEnd);
            const endIdx = Math.max(selectionStart, selectionEnd);

            const startPoint = currentTimeline[startIdx];
            const endPoint = currentTimeline[endIdx];

            if (!startPoint || !endPoint) return;

            const startShares = sumAtDate(startPoint.breakdown);
            const endShares = sumAtDate(endPoint.breakdown);
            const diffShares = endShares - startShares;

            const sharePrice = Number.parseFloat(sharePriceInput.value) || 0;
            const startValue = calculateValueFromBreakdown(startPoint.breakdown, sharePrice);
            const endValue = calculateValueFromBreakdown(endPoint.breakdown, sharePrice);
            const diffValue = endValue - startValue;

            const diffTime = Math.abs(endPoint.date - startPoint.date);
            const diffDays = Math.ceil(diffTime / MS_IN_DAY);

            rangeSharesEl.textContent = `${diffShares > 0 ? '+' : ''}${formatNumber(diffShares)}`;
            rangeSharesEl.style.color = diffShares >= 0 ? '#10b981' : '#ef4444';

            rangeValueEl.textContent = sharePrice > 0 ? formatCurrency(diffValue, true) : '‚Äî';
            rangeValueEl.style.color = diffValue >= 0 ? '#10b981' : '#ef4444';

            rangePeriodEl.textContent = `${diffDays} days`;

            rangeOverlay.classList.add('visible');
        };

        /**
         * Create tooltip DOM element
         */
        const createTooltipElement = () => {
            const tooltipEl = document.createElement('div');
            tooltipEl.id = 'chart-tooltip';
            document.body.appendChild(tooltipEl);
            return tooltipEl;
        };

        /**
         * Generate distinct color for each grant
         */
        const generateColor = index => {
            const palette = [
                '#3c82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6',
                '#14b8a6', '#ec4899', '#f97316', '#0ea5e9', '#84cc16',
                '#6366f1', '#f43f5e', '#06b6d4', '#a855f7', '#eab308'
            ];
            const base = palette[index % palette.length];
            return { base, alpha: hexToRgba(base, 0.5) };
        };

        /**
         * Convert hex color to rgba
         */
        const hexToRgba = (hex, alpha = 1) => {
            const sanitized = hex.replace('#', '');
            const bigint = parseInt(sanitized, 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        };

        /**
         * Render grant summary chips
         */
        const renderGrantSummary = grants => {
            grantSummary.innerHTML = grants.map((grant, idx) => {
                const color = generateColor(idx);
                const label = createGrantLabel(grant);
                const total = formatNumber(grant.grantTotal);
                const strikeInfo = grant.type === 'Option' ? ` | Strike: ${formatCurrency(grant.grantPrice)}` : '';

                return `<div class="chip" style="border-left: 3px solid ${color.base}">
                    <strong>${label}</strong>
                    <small>${grant.currency} | ${total} units${strikeInfo}</small>
                </div>`;
            }).join('');

            grantSummary.classList.toggle('hidden', !grants.length);
        };

        /**
         * Render table of upcoming vesting events
         */
        const renderUpcomingVests = () => {
            if (!upcomingTable || !upcomingTableBody || !upcomingEmptyState) return;

            if (!grantData.length) {
                upcomingTable.classList.add('hidden');
                upcomingEmptyState.classList.remove('hidden');
                upcomingEmptyState.textContent = 'Load grant files to see upcoming vesting events.';
                upcomingTableBody.innerHTML = '';
                return;
            }

            const todayIso = new Date().toISOString().slice(0, 10);
            const todayUtc = new Date(`${todayIso}T00:00:00Z`);
            const sharePrice = Number.parseFloat(sharePriceInput.value) || 0;
            const eventsMap = new Map();

            grantData.forEach(grant => {
                grant.entries.forEach(entry => {
                    if (!entry.date || !Number.isFinite(entry.granted) || entry.granted <= 0) return;
                    if (entry.date <= todayUtc) return;

                    const key = entry.date.toISOString().slice(0, 10);
                    if (!eventsMap.has(key)) {
                        eventsMap.set(key, {
                            date: entry.date,
                            totalShares: 0,
                            grants: []
                        });
                    }

                    const bucket = eventsMap.get(key);
                    bucket.totalShares += entry.granted;
                    bucket.grants.push({
                        label: grant.name || createGrantLabel(grant),
                        shares: entry.granted,
                        type: grant.type,
                        strike: grant.grantPrice
                    });
                });
            });

            const upcomingEvents = Array.from(eventsMap.values())
                .sort((a, b) => a.date - b.date)
                .slice(0, 10);

            if (!upcomingEvents.length) {
                upcomingTable.classList.add('hidden');
                upcomingEmptyState.classList.remove('hidden');
                upcomingEmptyState.textContent = 'All future vesting events are beyond the current horizon.';
                upcomingTableBody.innerHTML = '';
                return;
            }

            const rows = upcomingEvents.map(event => {
                const diffMs = event.date.getTime() - todayUtc.getTime();
                const daysUntil = Math.max(0, Math.ceil(diffMs / MS_IN_DAY));
                const totalValue = sharePrice > 0 ? event.grants.reduce((acc, item) => {
                    const perShare = item.type === 'Option' ? Math.max(sharePrice - item.strike, 0) : sharePrice;
                    return acc + (item.shares * perShare);
                }, 0) : 0;

                const breakdown = event.grants.map(item =>
                    `<div class="upcoming-grant-chip" title="${item.label}">
                        <span>${formatNumber(item.shares)}</span>
                        <span>${item.label}</span>
                    </div>`
                ).join('');

                return `<tr>
                    <td>${formatDateDisplay(event.date)}</td>
                    <td>${formatRelativeDays(daysUntil)}</td>
                    <td>${formatNumber(event.totalShares)}</td>
                    <td>${sharePrice > 0 ? formatCurrency(totalValue) : '‚Äî'}</td>
                    <td class="upcoming-details-cell">${breakdown}</td>
                </tr>`;
            }).join('');

            upcomingTableBody.innerHTML = rows;
            upcomingTable.classList.remove('hidden');
            upcomingEmptyState.classList.add('hidden');
        };

        /**
         * Get vested shares as of today
         */
        const getVestedAsOfToday = () => {
            const now = new Date();
            const breakdown = {};

            grantData.forEach(grant => {
                const vestedEntries = grant.entries.filter(entry => entry.date && entry.date <= now);
                if (vestedEntries.length > 0) {
                    const latest = vestedEntries[vestedEntries.length - 1];
                    breakdown[grant.id] = latest.cumulative;
                } else {
                    breakdown[grant.id] = 0;
                }
            });

            return breakdown;
        };

        /**
         * Calculate total value for vested shares as of today
         */
        const calculateCurrentValue = (sharePrice) => {
            const now = new Date();

            return grantData.reduce((acc, grant) => {
                const vestedEntries = grant.entries.filter(entry => entry.date && entry.date <= now);
                if (vestedEntries.length === 0) return acc;

                const latest = vestedEntries[vestedEntries.length - 1];
                const vested = latest.cumulative;
                const strike = grant.type === 'Option' ? grant.grantPrice : 0;
                const perShare = grant.type === 'Option' ? Math.max(sharePrice - strike, 0) : sharePrice;

                return acc + vested * perShare;
            }, 0);
        };

        /**
         * Update metrics display
         */
        const updateMetrics = () => {
            const sharePrice = Number.parseFloat(sharePriceInput.value) || 0;
            const percentChange = Number.parseFloat(priceChangeInput.value) || 0;

            const setDeltaState = (element, state, text) => {
                if (!element) return;
                element.classList.remove('delta-positive', 'delta-negative', 'delta-zero');
                element.classList.add(state);
                element.textContent = text;
            };

            if (!grantData.length) {
                baselineBreakdown = {};
                baselineTotalShares = 0;
                totalSharesEl.textContent = '0';
                totalValueEl.textContent = formatCurrency(0);
                projectedValueEl.textContent = formatCurrency(0);
                setDeltaState(shareDeltaDisplay, 'delta-zero', 'Load grant files to see next vest');
                setDeltaState(valueDeltaDisplay, 'delta-zero', 'Enter share price to see value change');
                priceChangeResult.textContent = 'Enter a share price and % change to calculate projected value.';
                renderUpcomingVests();
                renderChart();
                return;
            }

            const vestedToday = getVestedAsOfToday();
            const totalShares = sumAtDate(vestedToday);
            const currentValue = calculateCurrentValue(sharePrice);
            const projectedPrice = sharePrice * (1 + percentChange / 100);
            const projectedValue = calculateCurrentValue(projectedPrice);

            baselineBreakdown = vestedToday;
            baselineTotalShares = totalShares;

            totalSharesEl.textContent = formatNumber(totalShares);
            totalValueEl.textContent = formatCurrency(currentValue);
            projectedValueEl.textContent = formatCurrency(projectedValue);

            const now = new Date();
            const nextPoint = getNextFuturePoint(now);

            if (nextPoint) {
                const nextTotal = sumAtDate(nextPoint.breakdown);
                const shareDelta = nextTotal - totalShares;
                const formattedDate = formatDateDisplay(nextPoint.date);
                if (shareDelta > 0) {
                    setDeltaState(shareDeltaDisplay, 'delta-positive', `Next: +${formatNumber(shareDelta)} shares on ${formattedDate}`);
                } else if (shareDelta < 0) {
                    setDeltaState(shareDeltaDisplay, 'delta-negative', `Next: ${formatNumber(shareDelta)} shares on ${formattedDate}`);
                } else {
                    setDeltaState(shareDeltaDisplay, 'delta-zero', `Next on ${formattedDate} (no new shares)`);
                }

                if (sharePrice > 0) {
                    const nextValue = calculateValueFromBreakdown(nextPoint.breakdown, sharePrice);
                    const valueDelta = nextValue - currentValue;
                    if (valueDelta > 0) {
                        let text = `Next: ${formatCurrency(valueDelta, true)} on ${formattedDate}`;
                        if (currencyCode === 'AUD' && Number.isFinite(audUsdRate)) {
                            text += ` (${formatUsd(valueDelta * audUsdRate)})`;
                        }
                        setDeltaState(valueDeltaDisplay, 'delta-positive', text);
                    } else if (valueDelta < 0) {
                        let text = `Next: ${formatCurrency(valueDelta, true)} on ${formattedDate}`;
                        if (currencyCode === 'AUD' && Number.isFinite(audUsdRate)) {
                            text += ` (${formatUsd(valueDelta * audUsdRate)})`;
                        }
                        setDeltaState(valueDeltaDisplay, 'delta-negative', text);
                    } else {
                        setDeltaState(valueDeltaDisplay, 'delta-zero', `Next on ${formattedDate} (no value change at this price)`);
                    }
                } else {
                    setDeltaState(valueDeltaDisplay, 'delta-zero', 'Enter share price to see value change');
                }
            } else {
                setDeltaState(shareDeltaDisplay, 'delta-zero', 'All scheduled grants fully vested');
                if (sharePrice > 0) {
                    setDeltaState(valueDeltaDisplay, 'delta-zero', 'No upcoming value change');
                } else {
                    setDeltaState(valueDeltaDisplay, 'delta-zero', 'Enter share price to see value change');
                }
            }

            if (sharePrice > 0) {
                const delta = projectedValue - currentValue;
                const direction = delta >= 0 ? 'üìà Increase' : 'üìâ Decrease';
                const deltaText = formatCurrency(Math.abs(delta));
                const projectedText = formatCurrency(projectedValue);
                let inner = `
                    <strong>${direction}</strong>
                    Projected value: ${projectedText}<br>
                    Change: ${delta >= 0 ? '+' : '-'}${deltaText} (${percentChange >= 0 ? '+' : ''}${percentChange}%)
                `;
                if (currencyCode === 'AUD' && Number.isFinite(audUsdRate)) {
                    const currentUsd = formatUsd(currentValue * audUsdRate);
                    const projectedUsd = formatUsd(projectedValue * audUsdRate);
                    inner += `<br><small>‚âà ${currentUsd} now ‚Ä¢ ${projectedUsd} projected</small>`;
                }
                priceChangeResult.innerHTML = inner;
            } else {
                priceChangeResult.textContent = 'Enter a share price and % change to calculate projected value.';
            }

            renderUpcomingVests();
            renderChart();
        };

        /**
         * Calculate total portfolio value at a given price
         */
        const calculateTotalValue = price => {
            return grantData.reduce((acc, grant) => {
                const latest = grant.entries.at(-1);
                if (!latest) return acc;

                const vested = latest.cumulative;
                const strike = grant.type === 'Option' ? grant.grantPrice : 0;
                const perShare = grant.type === 'Option' ? Math.max(price - strike, 0) : price;

                return acc + vested * perShare;
            }, 0);
        };

        /**
         * Format number with commas
         */
        const formatNumber = value => {
            const formatter = new Intl.NumberFormat(undefined, {
                maximumFractionDigits: 2,
                minimumFractionDigits: 0
            });
            return formatter.format(value || 0);
        };

        /**
         * Format currency value
         */
        const formatCurrency = (value, signed = false) => {
            const formatter = new Intl.NumberFormat(undefined, {
                style: 'currency',
                currency: currencyCode,
                maximumFractionDigits: 2,
                signDisplay: signed ? 'always' : 'auto'
            });
            return formatter.format(value || 0);
        };

        /**
         * Format a date for display
         */
        const formatDateDisplay = date => {
            const formatter = new Intl.DateTimeFormat(undefined, {
                weekday: 'short',
                month: 'short',
                day: 'numeric',
                year: 'numeric'
            });
            return formatter.format(date);
        };

        const formatChartLabel = label => {
            if (!label) return '';
            const date = new Date(`${label}T00:00:00Z`);
            if (Number.isNaN(date.getTime())) return label;
            const formatter = new Intl.DateTimeFormat(undefined, {
                month: 'short',
                day: 'numeric'
            });
            return formatter.format(date);
        };

        const formatUsd = value => usdFormatter.format(value || 0);

        const formatTimestamp = date => {
            const formatter = new Intl.DateTimeFormat(undefined, {
                dateStyle: 'medium',
                timeStyle: 'short'
            });
            return formatter.format(date);
        };

        /**
         * Format a relative days string (e.g., "2 wk 3 d")
         */
        const formatRelativeDays = days => {
            if (days <= 0) return 'Today';
            if (days === 1) return 'Tomorrow';
            if (days < 7) return `${days} days`;

            const weeks = Math.floor(days / 7);
            const remainingDays = days % 7;

            if (weeks < 4) {
                if (remainingDays === 0) {
                    return `${weeks} ${weeks === 1 ? 'week' : 'weeks'}`;
                }
                return `${weeks} wk ${remainingDays} d`;
            }

            const months = Math.floor(days / 30);
            if (months >= 1) {
                const rem = days - months * 30;
                if (rem >= 7) {
                    const extraWeeks = Math.floor(rem / 7);
                    if (extraWeeks > 0) {
                        return `${months} ${months === 1 ? 'month' : 'months'} ${extraWeeks} wk`;
                    }
                }
                if (rem > 0) {
                    return `${months} ${months === 1 ? 'month' : 'months'} ${rem} d`;
                }
                return `${months} ${months === 1 ? 'month' : 'months'}`;
            }

            return `${weeks} weeks`;
        };

        const updateExchangeRateNotice = text => {
            if (!exchangeRateNotice) return;
            if (!text) {
                exchangeRateNotice.classList.add('hidden');
                exchangeRateNotice.textContent = '';
                return;
            }
            exchangeRateNotice.textContent = text;
            exchangeRateNotice.classList.remove('hidden');
        };

        const fetchAudUsdRate = () => {
            if (!exchangeRateNotice) return;
            updateExchangeRateNotice('Fetching live AUD ‚Üí USD rate‚Ä¶');
            fetch('https://open.er-api.com/v6/latest/AUD')
                .then(response => response.json())
                .then(data => {
                    const rate = data?.rates?.USD;
                    if (!Number.isFinite(rate)) {
                        throw new Error('USD rate missing');
                    }
                    audUsdRate = rate;
                    let lastUpdated = data?.time_last_update_utc ? new Date(data.time_last_update_utc) : new Date();
                    if (Number.isNaN(lastUpdated.getTime())) {
                        lastUpdated = new Date();
                    }
                    exchangeRateTimestamp = lastUpdated;
                    updateExchangeRateNotice(`1 AUD ‚âà ${formatUsd(rate)} ‚Ä¢ updated ${formatTimestamp(exchangeRateTimestamp)}`);
                })
                .catch(err => {
                    console.warn('Unable to fetch AUD ‚Üí USD rate', err);
                    updateExchangeRateNotice('Live AUD ‚Üí USD rate unavailable right now.');
                });
        };

        fetchAudUsdRate();

        /**
         * Caching Logic
         */
        const saveToCache = () => {
            const data = {
                grantData,
                sharePrice: sharePriceInput.value,
                priceChange: priceChangeInput.value,
                showFutureOnly: futureToggle.checked,
                timestamp: new Date().toISOString()
            };
            try {
                localStorage.setItem(CACHE_KEY, JSON.stringify(data));
            } catch (e) {
                console.warn('Failed to save to localStorage', e);
            }
        };

        const loadFromCache = () => {
            try {
                const cached = localStorage.getItem(CACHE_KEY);
                if (!cached) return;

                const data = JSON.parse(cached);

                // Restore inputs
                if (data.sharePrice !== undefined && data.sharePrice !== null) sharePriceInput.value = data.sharePrice;
                if (data.priceChange !== undefined && data.priceChange !== null) priceChangeInput.value = data.priceChange;
                if (data.showFutureOnly) {
                    showFutureOnly = data.showFutureOnly;
                    futureToggle.checked = showFutureOnly;
                }

                // Restore grants
                if (data.grantData && Array.isArray(data.grantData)) {
                    // Revive dates
                    grantData = data.grantData.map(grant => ({
                        ...grant,
                        entries: grant.entries.map(entry => ({
                            ...entry,
                            date: new Date(entry.date)
                        }))
                    }));

                    if (grantData.length > 0) {
                        updateUIWithData();
                    }
                }
            } catch (e) {
                console.warn('Failed to load from localStorage', e);
            }
        };

        const clearCache = (skipConfirm = false) => {
            if (!skipConfirm && !confirm('Are you sure you want to clear all loaded data?')) return;

            localStorage.removeItem(CACHE_KEY);
            grantData = [];
            timeline = [];
            chartInstance = null;

            // Reset UI
            fileInput.value = '';
            sharePriceInput.value = '';
            priceChangeInput.value = '';
            fileCountBadge.classList.add('hidden');
            clearCacheBtn.classList.add('hidden');
            uploadSection.classList.remove('hidden');
            grantSummary.innerHTML = '';
            grantSummary.classList.add('hidden');
            upcomingTableBody.innerHTML = '';
            upcomingEmptyState.classList.remove('hidden');
            upcomingTable.classList.add('hidden');

            updateMetrics();
            renderChart();
        };

        // Event Listeners
        clearCacheBtn.addEventListener('click', () => clearCache(false));
        uploadSection.addEventListener('click', () => fileInput.click());

        // Global Drag and Drop
        const dragOverlay = document.getElementById('dragOverlay');
        let dragCounter = 0;

        window.addEventListener('dragenter', (e) => {
            e.preventDefault();
            dragCounter++;
            dragOverlay.classList.add('visible');
        });

        window.addEventListener('dragleave', (e) => {
            dragCounter--;
            if (dragCounter === 0) {
                dragOverlay.classList.remove('visible');
            }
        });

        window.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        window.addEventListener('drop', (e) => {
            e.preventDefault();
            dragCounter = 0;
            dragOverlay.classList.remove('visible');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                if (grantData.length > 0) {
                    if (confirm('Do you want to clear existing data before loading new files?\n\nOK: Clear and Load\nCancel: Append to existing')) {
                        clearCache(true);
                    }
                }
                loadFiles(files);
            }
        });

        fileInput.addEventListener('change', evt => loadFiles(evt.target.files));
        futureToggle.addEventListener('change', (evt) => {
            showFutureOnly = evt.target.checked;
            renderChart();
            saveToCache();
        });
        sharePriceInput.addEventListener('input', () => {
            updateMetrics();
            saveToCache();
        });
        sharePriceInput.addEventListener('change', () => saveToCache());
        priceChangeInput.addEventListener('input', () => {
            updateMetrics();
            saveToCache();
        });

        // Hide tooltip on window resize
        window.addEventListener('resize', () => {
            const tooltip = document.getElementById('chart-tooltip');
            if (tooltip) tooltip.style.opacity = 0;
        });

        // Initialize
        loadFromCache();
        updateMetrics();
    </script>
    <!-- Drag Overlay -->
    <div id="dragOverlay">
        <div class="icon">üìÇ</div>
        <h2>Drop files to load</h2>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal-backdrop">
        <div class="modal-content">
            <button id="closeModal" class="modal-close" aria-label="Close help">&times;</button>
            <h2 style="margin-bottom: 1.5rem;">Getting Started</h2>

            <div class="help-step">
                <div class="help-step-number">1</div>
                <div class="help-step-content">
                    <h3>Export your data</h3>
                    <p>Log in to ShareWorks and navigate to the portfolio tab. Open up each grant that you have been
                        given for RSUs and Options. Right click on each page and hit "Save Page As..." and proceed to
                        save as HTML. Drag and drop all HTML files into the window.</p>
                </div>
            </div>

            <div class="help-step">
                <div class="help-step-number">2</div>
                <div class="help-step-content">
                    <h3>Analyze your equity</h3>
                    <p>Enter the current share price to see your total vested value. Use the "What If" calculator to
                        project future value based on price changes.</p>
                </div>
            </div>

            <div style="text-align: right; margin-top: 2rem;">
                <button id="gotItBtn" class="btn-secondary"
                    style="background: var(--accent); color: white; border: none;">Got it!</button>
            </div>
        </div>
    </div>

    <script>
        // Help Modal Logic
        const helpModal = document.getElementById('helpModal');
        const helpBtn = document.getElementById('helpBtn');
        const closeModal = document.getElementById('closeModal');
        const gotItBtn = document.getElementById('gotItBtn');
        const HELP_SEEN_KEY = 'shareworks_help_seen';

        const showHelp = () => {
            helpModal.classList.add('visible');
        };

        const hideHelp = () => {
            helpModal.classList.remove('visible');
            localStorage.setItem(HELP_SEEN_KEY, 'true');
        };

        helpBtn.addEventListener('click', showHelp);
        closeModal.addEventListener('click', hideHelp);
        gotItBtn.addEventListener('click', hideHelp);

        helpModal.addEventListener('click', (e) => {
            if (e.target === helpModal) hideHelp();
        });

        // Show on first visit
        if (!localStorage.getItem(HELP_SEEN_KEY)) {
            // Small delay to ensure smooth entrance
            setTimeout(showHelp, 500);
        }
    </script>
</body>

</html>